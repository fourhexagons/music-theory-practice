<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Music Theory Practice – Comprehensive Test Suite</title>
    <link rel="stylesheet" href="css/test-suite.css">
    <style>
        .test-result {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid;
            word-break: break-word;
            overflow-wrap: anywhere;
        }
        .test-result.pass {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        .test-result.fail {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        .test-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .status {
            font-weight: bold;
        }
        .test-details {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            margin: 4px 0;
        }
        .category-header {
            background-color: #e9ecef;
            padding: 10px;
            margin: 20px 0 10px 0;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.1em;
        }
        .test-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        .test-controls .btn {
            flex: 1;
            min-width: 150px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
        .progress-fill.complete {
            background-color: #28a745;
        }
        .progress-fill.error {
            background-color: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧪 Music Theory Practice – Comprehensive Test Suite</h1>
            <p>Complete test coverage for all app functionality. Run all tests in one place.</p>
        </div>
        <div class="content-box">
            <div id="summary" class="summary" style="display:none;">
                <div id="summary-content"></div>
                    </div>
            <div class="test-controls">
                <button class="btn" onclick="runAllTests()">Run All Tests</button>
                <button class="btn" onclick="runCoreTests()">Core Logic Only</button>
                <button class="btn" onclick="runDataTests()">Data & Validation Only</button>
                <button class="btn" onclick="runUITests()">UI & Integration Only</button>
                <button class="btn" onclick="runAdvancedTests()">Advanced Features Only</button>
                <button class="btn" onclick="runPerformanceTests()">Performance Only</button>
                <button class="btn" onclick="copyResults()">Copy Results (JSON)</button>
                <button class="btn" onclick="clearResults()">Clear Results</button>
                    </div>
            <div id="progress-container" style="display:none;">
                <div class="progress-bar">
                    <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                </div>
                <div id="progress-text">Ready to run tests...</div>
            </div>
            <div id="copy-status" class="status-area"></div>
            <div id="results"></div>
        </div>
    </div>
    <script src="../js/data/quizData.js"></script>
    <script src="../js/utils/normalization.js"></script>
    <script src="../js/utils/helpers.js"></script>
    <script src="../js/utils/validation.js"></script>
    <script src="../js/state/learningState.js"></script>
    <script src="../js/utils/errorHandler.js"></script>
    <script src="../js/practice-menu.js"></script>
    <script>
        // Test Results Storage
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            tests: []
        };

        // Test Categories
        const TEST_CATEGORIES = {
            CORE: 'Core Logic',
            DATA: 'Data & Validation', 
            UI: 'UI & Integration',
            ADVANCED: 'Advanced Features',
            PERFORMANCE: 'Performance'
        };

        // Test Suite Definition
        const TEST_SUITE = {
            [TEST_CATEGORIES.CORE]: [
                {
                    name: 'Learning State Initialization',
                    category: TEST_CATEGORIES.CORE,
                    test: () => {
                        const state = window.learningState;
                        return {
                            passed: state && typeof state.currentChapterIndex === 'number',
                            details: `State initialized: ${!!state}, Chapter index: ${state?.currentChapterIndex}`
                        };
                    }
                },
                {
                    name: 'Question Generation',
                    category: TEST_CATEGORIES.CORE,
                    test: () => {
                        const question = window.generateQuestion();
                        return {
                            passed: !!(question && question.questionText && question.expectedAnswer !== null && question.expectedAnswer !== undefined),
                            details: `Generated question: ${question?.questionText || 'null'}`
                        };
                    }
                },
                {
                    name: 'Level Progression',
                    category: TEST_CATEGORIES.CORE,
                    test: () => {
                        const level = window.getCurrentLevel();
                        return {
                            passed: level && level.chapters && level.keys,
                            details: `Current level: ${level?.name || 'null'}`
                        };
                    }
                },
                {
                    name: 'Skip Logic for C Major',
                    category: TEST_CATEGORIES.CORE,
                    test: () => {
                        // Test that C major skips accidentals naming
                        const originalState = { ...window.learningState };
                        window.learningState.currentKeyIndex = 0; // C major
                        window.learningState.currentChapterIndex = 1; // accNotes
                        
                        const question = window.generateQuestion();
                        const skipped = question.chapterId !== 'accNotes';
                        
                        // Restore state
                        window.learningState = originalState;
                        
                        return {
                            passed: skipped,
                            details: `C major skip logic: ${skipped ? 'working' : 'failed'}`
                        };
                    }
                }
            ],
            [TEST_CATEGORIES.DATA]: [
                {
                    name: 'Quiz Data Loading',
                    category: TEST_CATEGORIES.DATA,
                    test: () => {
                        return {
                            passed: window.quizData && Object.keys(window.quizData).length > 0,
                            details: `Loaded ${Object.keys(window.quizData || {}).length} keys`
                        };
                    }
                },
                {
                    name: 'Data Completeness',
                    category: TEST_CATEGORIES.DATA,
                    test: () => {
                        const keys = Object.keys(window.quizData || {});
                        let allComplete = true;
                        let missingData = [];
                        
                        keys.forEach(key => {
                            const keyData = window.quizData[key];
                            if (!keyData.scale || !keyData.triads || !keyData.sevenths) {
                                allComplete = false;
                                missingData.push(key);
                            }
                        });
                        
                        return {
                            passed: allComplete,
                            details: `Data complete: ${allComplete}, Missing: ${missingData.join(', ') || 'none'}`
                        };
                    }
                },
                {
                    name: 'Note Normalization',
                    category: TEST_CATEGORIES.DATA,
                    test: () => {
                        const testCases = [
                            { input: 'C#', expected: 'C♯' },
                            { input: 'Db', expected: 'D♭' },
                            { input: 'F##', expected: 'F𝄪' },
                            { input: 'Bbb', expected: 'B𝄫' }
                        ];
                        
                        let passed = 0;
                        let details = [];
                        
                        testCases.forEach(({ input, expected }) => {
                            const result = window.accidentalToUnicode(input);
                            const success = result === expected;
                            if (success) passed++;
                            details.push(`${input} → ${result} ${success ? '✓' : '✗'}`);
                        });
                        
                        return {
                            passed: passed === testCases.length,
                            details: details.join(', ')
                        };
                    }
                },
                {
                    name: 'Comprehensive User Input Validation',
                    category: TEST_CATEGORIES.DATA,
                    test: () => {
                        const testResults = {
                            scaleInputs: testScaleInputs(),
                            chordInputs: testChordInputs(),
                            accidentalsInputs: testAccidentalsInputs(),
                            numericInputs: testNumericInputs(),
                            edgeCases: testEdgeCases()
                        };
                        
                        const totalTests = Object.values(testResults).reduce((sum, result) => sum + result.total, 0);
                        const totalPassed = Object.values(testResults).reduce((sum, result) => sum + result.passed, 0);
                        
                        return {
                            passed: totalPassed === totalTests,
                            details: `Scale: ${testResults.scaleInputs.passed}/${testResults.scaleInputs.total}, ` +
                                    `Chords: ${testResults.chordInputs.passed}/${testResults.chordInputs.total}, ` +
                                    `Accidentals: ${testResults.accidentalsInputs.passed}/${testResults.accidentalsInputs.total}, ` +
                                    `Numbers: ${testResults.numericInputs.passed}/${testResults.numericInputs.total}, ` +
                                    `Edges: ${testResults.edgeCases.passed}/${testResults.edgeCases.total}`
                        };
                    }
                },
                {
                    name: 'Answer Validation',
                    category: TEST_CATEGORIES.DATA,
                    test: () => {
                        // Create a simple validateAnswer function for testing
                        const validateAnswer = (answer, expected) => {
                            if (!answer || !expected) return false;
                            const normalizedAnswer = answer.trim().toLowerCase().replace(/,/g, ' ');
                            const normalizedExpected = expected.trim().toLowerCase().replace(/,/g, ' ');
                            return normalizedAnswer === normalizedExpected;
                        };
                        
                        const testCases = [
                            { answer: 'C E G', expected: 'C E G', shouldPass: true },
                            { answer: 'C,E,G', expected: 'C E G', shouldPass: true },
                            { answer: 'C E G', expected: 'C F G', shouldPass: false }
                        ];
                        
                        let passed = 0;
                        let details = [];
                        
                        testCases.forEach(({ answer, expected, shouldPass }) => {
                            const result = validateAnswer(answer, expected);
                            const success = result === shouldPass;
                            if (success) passed++;
                            details.push(`${answer} vs ${expected}: ${result} ${success ? '✓' : '✗'}`);
                        });
                        
                        return {
                            passed: passed === testCases.length,
                            details: details.join(', ')
                        };
                    }
                }
            ],
            [TEST_CATEGORIES.UI]: [
                {
                    name: 'DOM Element Access',
                    category: TEST_CATEGORIES.UI,
                    test: () => {
                        const testElement = document.createElement('div');
                        testElement.id = 'test-element';
                        document.body.appendChild(testElement);
                        
                        const result = window.MusicTheoryHelpers.getElement('test-element');
                        document.body.removeChild(testElement);
                        
                        return {
                            passed: result && result.id === 'test-element',
                            details: `Element access: ${result ? 'working' : 'failed'}`
                        };
                    }
                },
                {
                    name: 'Helper Functions',
                    category: TEST_CATEGORIES.UI,
                    test: () => {
                        const testElement = document.createElement('div');
                        testElement.id = 'helper-test';
                        document.body.appendChild(testElement);
                        
                        let passed = 0;
                        const tests = [
                            () => { window.MusicTheoryHelpers.setElementText('helper-test', 'test'); return testElement.textContent === 'test'; },
                            () => { window.MusicTheoryHelpers.setElementClass('helper-test', 'test-class'); return testElement.className === 'test-class'; },
                            () => { window.MusicTheoryHelpers.setElementDisplay('helper-test', 'none'); return testElement.style.display === 'none'; }
                        ];
                        
                        tests.forEach(test => {
                            if (test()) passed++;
                        });
                        
                        document.body.removeChild(testElement);
                        
                        return {
                            passed: passed === tests.length,
                            details: `${passed}/${tests.length} helper functions working`
                        };
                    }
                }
            ],
            [TEST_CATEGORIES.ADVANCED]: [
                {
                    name: 'Seventh Chord Data',
                    category: TEST_CATEGORIES.ADVANCED,
                    test: () => {
                        const keys = Object.keys(window.quizData || {});
                        let allHaveSevenths = true;
                        let missingSevenths = [];
                        
                        keys.forEach(key => {
                            const keyData = window.quizData[key];
                            if (!keyData.sevenths || Object.keys(keyData.sevenths).length !== 7) {
                                allHaveSevenths = false;
                                missingSevenths.push(key);
                            }
                        });
                        
                        return {
                            passed: allHaveSevenths,
                            details: `Seventh chords complete: ${allHaveSevenths}, Missing: ${missingSevenths.join(', ') || 'none'}`
                        };
                    }
                },
                {
                    name: 'Chord Degree Validation',
                    category: TEST_CATEGORIES.ADVANCED,
                    test: () => {
                        const testKey = 'C';
                        const keyData = window.quizData[testKey];
                        let passed = 0;
                        let details = [];
                        
                        for (let degree = 1; degree <= 7; degree++) {
                            const triad = keyData.triads[degree.toString()];
                            const seventh = keyData.sevenths[degree.toString()];
                            
                            if (triad && seventh) {
                                passed++;
                                details.push(`Degree ${degree}: ✓`);
                            } else {
                                details.push(`Degree ${degree}: ✗`);
                            }
                        }
                        
                        return {
                            passed: passed === 7,
                            details: details.join(', ')
                        };
                    }
                }
            ],
            [TEST_CATEGORIES.PERFORMANCE]: [
                {
                    name: 'Question Generation Performance',
                    category: TEST_CATEGORIES.PERFORMANCE,
                    test: () => {
                        const start = performance.now();
                        let questions = [];
                        
                        for (let i = 0; i < 100; i++) {
                            questions.push(window.generateQuestion());
                        }
                        
                        const end = performance.now();
                        const duration = end - start;
                        
                        return {
                            passed: duration < 1000, // Should complete in under 1 second
                            details: `Generated 100 questions in ${duration.toFixed(2)}ms`
                        };
                    }
                },
                {
                    name: 'Data Access Performance',
                    category: TEST_CATEGORIES.PERFORMANCE,
                    test: () => {
                        const start = performance.now();
                        const keys = Object.keys(window.quizData || {});
                        
                        keys.forEach(key => {
                            const keyData = window.quizData[key];
                            // Access all properties
                            keyData.scale;
                            keyData.triads;
                            keyData.sevenths;
                            keyData.accidentals;
                            keyData.notes;
                        });
                        
                        const end = performance.now();
                        const duration = end - start;
                        
                        return {
                            passed: duration < 100, // Should complete in under 100ms
                            details: `Accessed all data in ${duration.toFixed(2)}ms`
                        };
                    }
                }
            ]
        };

        // Test Runner Functions
        function runAllTests() {
            const allTests = Object.values(TEST_SUITE).flat();
            runTestCategory('All Tests', allTests);
        }

        function runCoreTests() {
            runTestCategory(TEST_CATEGORIES.CORE, TEST_SUITE[TEST_CATEGORIES.CORE]);
        }

        function runDataTests() {
            runTestCategory(TEST_CATEGORIES.DATA, TEST_SUITE[TEST_CATEGORIES.DATA]);
        }

        function runUITests() {
            runTestCategory(TEST_CATEGORIES.UI, TEST_SUITE[TEST_CATEGORIES.UI]);
        }

        function runAdvancedTests() {
            runTestCategory(TEST_CATEGORIES.ADVANCED, TEST_SUITE[TEST_CATEGORIES.ADVANCED]);
        }

        function runPerformanceTests() {
            runTestCategory(TEST_CATEGORIES.PERFORMANCE, TEST_SUITE[TEST_CATEGORIES.PERFORMANCE]);
        }

        function runTestCategory(categoryName, tests) {
            // Reset results
            testResults = {
                total: tests.length,
                passed: 0,
                failed: 0,
                tests: [],
                category: categoryName,
                timestamp: new Date().toISOString()
            };

            // Show progress
            const progressContainer = document.getElementById('progress-container');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            progressFill.className = 'progress-fill';
            progressText.textContent = `Running ${categoryName}...`;

            // Clear results area
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            // Run tests
            let completed = 0;
            tests.forEach((test, index) => {
                    setTimeout(() => {
                    try {
                        const result = test.test();
                        const testResult = {
                            name: test.name,
                            category: test.category,
                            passed: result.passed,
                            details: result.details,
                            timestamp: new Date().toISOString()
                        };

                        testResults.tests.push(testResult);
                        
                        if (result.passed) {
                            testResults.passed++;
                        } else {
                            testResults.failed++;
                        }

                        // Update progress
                        completed++;
                        const progress = (completed / tests.length) * 100;
                        progressFill.style.width = `${progress}%`;
                        
                        if (completed === tests.length) {
                            progressFill.className = 'progress-fill complete';
                            progressText.textContent = 'Tests completed!';
                        }

                        // Display result
                        displayTestResult(testResult);

                    } catch (error) {
                        const testResult = {
                            name: test.name,
                            category: test.category,
                            passed: false,
                            details: `Error: ${error.message}`,
                            timestamp: new Date().toISOString()
                        };

                        testResults.tests.push(testResult);
                        testResults.failed++;
                        completed++;

                        const progress = (completed / tests.length) * 100;
                        progressFill.style.width = `${progress}%`;
                        progressFill.className = 'progress-fill error';
                        progressText.textContent = 'Tests completed with errors!';

                        displayTestResult(testResult);
                    }
                }, index * 50); // Stagger test execution
            });

            // Display summary after all tests complete
            setTimeout(() => {
                displaySummary();
            }, tests.length * 50 + 100);
        }

        function displayTestResult(testResult) {
            const resultsDiv = document.getElementById('results');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${testResult.passed ? 'pass' : 'fail'}`;
            
            resultDiv.innerHTML = `
                <div class="status">${testResult.passed ? '✓ PASS' : '✗ FAIL'}: ${testResult.name}</div>
                <div class="test-details">${testResult.details}</div>
            `;
            
            resultsDiv.appendChild(resultDiv);
        }

        function displaySummary() {
            const summaryDiv = document.getElementById('summary');
            const summaryContent = document.getElementById('summary-content');
            
            const successRate = testResults.total > 0 ? ((testResults.passed / testResults.total) * 100).toFixed(1) : '0';
            
            summaryContent.innerHTML = `
                <h3>Test Summary: ${testResults.category}</h3>
                <p><strong>Total Tests:</strong> ${testResults.total}</p>
                <p><strong>Passed:</strong> ${testResults.passed}</p>
                <p><strong>Failed:</strong> ${testResults.failed}</p>
                <p><strong>Success Rate:</strong> ${successRate}%</p>
                <p><strong>Completed:</strong> ${new Date(testResults.timestamp).toLocaleString()}</p>
            `;
            
            summaryDiv.style.display = 'block';
        }

        function copyResults() {
            const resultsText = JSON.stringify(testResults, null, 2);
            navigator.clipboard.writeText(resultsText).then(() => {
                const statusDiv = document.getElementById('copy-status');
                statusDiv.textContent = 'Results copied to clipboard!';
                statusDiv.style.display = 'block';
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }).catch(err => {
                console.error('Failed to copy results:', err);
                alert('Failed to copy results to clipboard');
            });
        }

        function clearResults() {
            testResults = {
                total: 0,
                passed: 0,
                failed: 0,
                tests: []
            };
            
            document.getElementById('results').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            document.getElementById('progress-container').style.display = 'none';
            document.getElementById('copy-status').style.display = 'none';
        }

        // Comprehensive Input Testing Functions
        function testScaleInputs() {
            const testCases = [
                // Valid scale inputs
                { input: 'C D E F G A B', expected: 'C D E F G A B', shouldPass: true },
                { input: 'C,D,E,F,G,A,B', expected: 'C D E F G A B', shouldPass: true },
                { input: 'C  D  E  F  G  A  B', expected: 'C D E F G A B', shouldPass: true },
                { input: 'c d e f g a b', expected: 'C D E F G A B', shouldPass: true },
                { input: 'C♯ D♯ E F♯ G♯ A♯ B', expected: 'C♯ D♯ E F♯ G♯ A♯ B', shouldPass: true },
                { input: 'C# D# E F# G# A# B', expected: 'C♯ D♯ E F♯ G♯ A♯ B', shouldPass: true },
                { input: 'D♭ E♭ F G♭ A♭ B♭ C', expected: 'D♭ E♭ F G♭ A♭ B♭ C', shouldPass: true },
                { input: 'Db Eb F Gb Ab Bb C', expected: 'D♭ E♭ F G♭ A♭ B♭ C', shouldPass: true },
                
                // Invalid scale inputs
                { input: 'C D E F G A', expected: 'C D E F G A B', shouldPass: false }, // Missing note
                { input: 'C D E F G A B C', expected: 'C D E F G A B', shouldPass: false }, // Extra note
                { input: 'C D E F G A B D', expected: 'C D E F G A B', shouldPass: false }, // Wrong note
                { input: 'X Y Z', expected: 'C D E F G A B', shouldPass: false }, // Invalid notes
                { input: '', expected: 'C D E F G A B', shouldPass: false }, // Empty
                { input: '   ', expected: 'C D E F G A B', shouldPass: false }, // Whitespace only
                
                // Edge cases
                { input: 'C,D,E,F,G,A,B,', expected: 'C D E F G A B', shouldPass: true }, // Trailing comma
                { input: ',C,D,E,F,G,A,B', expected: 'C D E F G A B', shouldPass: true }, // Leading comma
                { input: 'C,,D,,E,,F,,G,,A,,B', expected: 'C D E F G A B', shouldPass: true }, // Multiple commas
                { input: 'C\tD\tE\tF\tG\tA\tB', expected: 'C D E F G A B', shouldPass: true }, // Tabs
                { input: 'C\nD\nE\nF\nG\nA\nB', expected: 'C D E F G A B', shouldPass: true }, // Newlines
            ];
            
            let passed = 0;
            testCases.forEach(({ input, expected, shouldPass }) => {
                const result = validateScaleInput(input, expected);
                if (result === shouldPass) passed++;
            });
            
            return { total: testCases.length, passed };
        }

        function testChordInputs() {
            const testCases = [
                // Valid triad inputs
                { input: 'C E G', expected: 'C E G', shouldPass: true },
                { input: 'C,E,G', expected: 'C E G', shouldPass: true },
                { input: 'C♯ E♯ G♯', expected: 'C♯ E♯ G♯', shouldPass: true },
                { input: 'C# E# G#', expected: 'C♯ E♯ G♯', shouldPass: true },
                { input: 'D♭ F A♭', expected: 'D♭ F A♭', shouldPass: true },
                { input: 'Db F Ab', expected: 'D♭ F A♭', shouldPass: true },
                
                // Valid seventh chord inputs
                { input: 'C E G B', expected: 'C E G B', shouldPass: true },
                { input: 'C,E,G,B', expected: 'C E G B', shouldPass: true },
                { input: 'C♯ E♯ G♯ B♯', expected: 'C♯ E♯ G♯ B♯', shouldPass: true },
                { input: 'D♭ F A♭ C♭', expected: 'D♭ F A♭ C♭', shouldPass: true },
                
                // Invalid chord inputs
                { input: 'C E', expected: 'C E G', shouldPass: false }, // Missing note
                { input: 'C E G B D', expected: 'C E G B', shouldPass: false }, // Extra note
                { input: 'C E F', expected: 'C E G', shouldPass: false }, // Wrong note
                { input: 'X Y Z', expected: 'C E G', shouldPass: false }, // Invalid notes
                { input: '', expected: 'C E G', shouldPass: false }, // Empty
                
                // Edge cases
                { input: 'C,E,G,', expected: 'C E G', shouldPass: true }, // Trailing comma
                { input: ',C,E,G', expected: 'C E G', shouldPass: true }, // Leading comma
                { input: 'C,,E,,G', expected: 'C E G', shouldPass: true }, // Multiple commas
                { input: 'C\tE\tG', expected: 'C E G', shouldPass: true }, // Tabs
                { input: 'C\nE\nG', expected: 'C E G', shouldPass: true }, // Newlines
            ];
            
            let passed = 0;
            testCases.forEach(({ input, expected, shouldPass }) => {
                const result = validateChordInput(input, expected);
                if (result === shouldPass) passed++;
            });
            
            return { total: testCases.length, passed };
        }

        function testAccidentalsInputs() {
            const testCases = [
                // Valid accidentals inputs
                { input: 'F♯ C♯', expected: 'F♯ C♯', shouldPass: true },
                { input: 'F#,C#', expected: 'F♯ C♯', shouldPass: true },
                { input: 'F# C#', expected: 'F♯ C♯', shouldPass: true },
                { input: 'B♭ E♭ A♭', expected: 'B♭ E♭ A♭', shouldPass: true },
                { input: 'Bb,Eb,Ab', expected: 'B♭ E♭ A♭', shouldPass: true },
                { input: 'Bb Eb Ab', expected: 'B♭ E♭ A♭', shouldPass: true },
                { input: 'F𝄪 C𝄪', expected: 'F𝄪 C𝄪', shouldPass: true },
                { input: 'F## C##', expected: 'F𝄪 C𝄪', shouldPass: true },
                { input: 'B𝄫 E𝄫', expected: 'B𝄫 E𝄫', shouldPass: true },
                { input: 'Bbb Ebb', expected: 'B𝄫 E𝄫', shouldPass: true },
                
                // Invalid accidentals inputs
                { input: 'F♯', expected: 'F♯ C♯', shouldPass: false }, // Missing note
                { input: 'F♯ C♯ G♯', expected: 'F♯ C♯', shouldPass: false }, // Extra note
                { input: 'F♯ D♯', expected: 'F♯ C♯', shouldPass: false }, // Wrong note
                { input: 'X Y', expected: 'F♯ C♯', shouldPass: false }, // Invalid notes
                { input: '', expected: 'F♯ C♯', shouldPass: false }, // Empty
                
                // Edge cases
                { input: 'F♯,C♯,', expected: 'F♯ C♯', shouldPass: true }, // Trailing comma
                { input: ',F♯,C♯', expected: 'F♯ C♯', shouldPass: true }, // Leading comma
                { input: 'F♯,,C♯', expected: 'F♯ C♯', shouldPass: true }, // Multiple commas
                { input: 'F♯\tC♯', expected: 'F♯ C♯', shouldPass: true }, // Tabs
                { input: 'F♯\nC♯', expected: 'F♯ C♯', shouldPass: true }, // Newlines
            ];
            
            let passed = 0;
            testCases.forEach(({ input, expected, shouldPass }) => {
                const result = validateAccidentalsInput(input, expected);
                if (result === shouldPass) passed++;
            });
            
            return { total: testCases.length, passed };
        }

        function testNumericInputs() {
            const testCases = [
                // Valid numeric inputs for accidentals count
                { input: '0', expected: 0, shouldPass: true },
                { input: '1', expected: 1, shouldPass: true },
                { input: '2', expected: 2, shouldPass: true },
                { input: '3', expected: 3, shouldPass: true },
                { input: '4', expected: 4, shouldPass: true },
                { input: '5', expected: 5, shouldPass: true },
                { input: '6', expected: 6, shouldPass: true },
                { input: '7', expected: 7, shouldPass: true },
                
                // Word representations
                { input: 'zero', expected: 0, shouldPass: true },
                { input: 'one', expected: 1, shouldPass: true },
                { input: 'two', expected: 2, shouldPass: true },
                { input: 'three', expected: 3, shouldPass: true },
                { input: 'four', expected: 4, shouldPass: true },
                { input: 'five', expected: 5, shouldPass: true },
                { input: 'six', expected: 6, shouldPass: true },
                { input: 'seven', expected: 7, shouldPass: true },
                
                // Case variations
                { input: 'ZERO', expected: 0, shouldPass: true },
                { input: 'One', expected: 1, shouldPass: true },
                { input: 'TWO', expected: 2, shouldPass: true },
                
                // Invalid numeric inputs
                { input: '8', expected: 7, shouldPass: false }, // Out of range
                { input: '-1', expected: 0, shouldPass: false }, // Negative
                { input: '1.5', expected: 1, shouldPass: false }, // Decimal
                { input: 'abc', expected: 0, shouldPass: false }, // Non-numeric
                { input: '', expected: 0, shouldPass: false }, // Empty
                { input: '   ', expected: 0, shouldPass: false }, // Whitespace
                { input: 'eight', expected: 7, shouldPass: false }, // Out of range word
                { input: 'none', expected: 0, shouldPass: true }, // Special case for zero
                
                // Edge cases
                { input: ' 1 ', expected: 1, shouldPass: true }, // Leading/trailing spaces
                { input: '\t2\t', expected: 2, shouldPass: true }, // Tabs
                { input: '\n3\n', expected: 3, shouldPass: true }, // Newlines
            ];
            
            let passed = 0;
            let failedCases = [];
            testCases.forEach(({ input, expected, shouldPass }, index) => {
                const result = validateNumericInput(input, expected);
                if (result === shouldPass) {
                    passed++;
                } else {
                    failedCases.push(`Case ${index + 1}: "${input}" expected ${expected} shouldPass=${shouldPass} but got ${result}`);
                }
            });
            
            if (failedCases.length > 0) {
                console.log('Numeric input validation failures:', failedCases);
            }
            
            return { total: testCases.length, passed };
        }

        function testEdgeCases() {
            const testCases = [
                // Unicode and special characters
                { input: 'C♯ D♯ E♯ F♯ G♯ A♯ B♯', expected: 'C♯ D♯ E♯ F♯ G♯ A♯ B♯', shouldPass: true },
                { input: 'C♭ D♭ E♭ F♭ G♭ A♭ B♭', expected: 'C♭ D♭ E♭ F♭ G♭ A♭ B♭', shouldPass: true },
                { input: 'C𝄪 D𝄪 E𝄪 F𝄪 G𝄪 A𝄪 B𝄪', expected: 'C𝄪 D𝄪 E𝄪 F𝄪 G𝄪 A𝄪 B𝄪', shouldPass: true },
                { input: 'C𝄫 D𝄫 E𝄫 F𝄫 G𝄫 A𝄫 B𝄫', expected: 'C𝄫 D𝄫 E𝄫 F𝄫 G𝄫 A𝄫 B𝄫', shouldPass: true },
                
                // Mixed formats
                { input: 'C♯ D# E♯ F# G♯ A# B♯', expected: 'C♯ D♯ E♯ F♯ G♯ A♯ B♯', shouldPass: true },
                { input: 'C♭ Db E♭ Fb G♭ Ab B♭', expected: 'C♭ D♭ E♭ F♭ G♭ A♭ B♭', shouldPass: true },
                
                // Extreme whitespace
                { input: '   C   D   E   F   G   A   B   ', expected: 'C D E F G A B', shouldPass: true },
                { input: '\t\nC\t\nD\t\nE\t\nF\t\nG\t\nA\t\nB\t\n', expected: 'C D E F G A B', shouldPass: true },
                
                // Mixed separators
                { input: 'C,D E,F G,A B', expected: 'C D E F G A B', shouldPass: true },
                { input: 'C, D, E, F, G, A, B', expected: 'C D E F G A B', shouldPass: true },
                
                // Invalid edge cases
                { input: 'C D E F G A B C D E F G A B', expected: 'C D E F G A B', shouldPass: false }, // Too many notes
                { input: 'C♯♯ D♯♯', expected: 'C♯ D♯', shouldPass: false }, // Double accidentals
                { input: 'C♭♭ D♭♭', expected: 'C♭ D♭', shouldPass: false }, // Double accidentals
                { input: 'C#b D#b', expected: 'C♯ D♯', shouldPass: false }, // Mixed accidentals
                { input: 'Cb# Db#', expected: 'C♭ D♭', shouldPass: false }, // Mixed accidentals
            ];
            
            let passed = 0;
            testCases.forEach(({ input, expected, shouldPass }) => {
                const result = validateEdgeCase(input, expected);
                if (result === shouldPass) passed++;
            });
            
            return { total: testCases.length, passed };
        }

        // Helper validation functions
        function validateScaleInput(input, expected) {
            if (!input || !expected) return false;
            const normalizedInput = normalizeInput(input);
            const normalizedExpected = normalizeInput(expected);
            return normalizedInput === normalizedExpected;
        }

        function validateChordInput(input, expected) {
            if (!input || !expected) return false;
            const normalizedInput = normalizeInput(input);
            const normalizedExpected = normalizeInput(expected);
            return normalizedInput === normalizedExpected;
        }

        function validateAccidentalsInput(input, expected) {
            if (!input || !expected) return false;
            const normalizedInput = normalizeInput(input);
            const normalizedExpected = normalizeInput(expected);
            return normalizedInput === normalizedExpected;
        }

        function validateNumericInput(input, expected) {
            if (!input) return false;
            const normalizedInput = input.trim().toLowerCase();
            
            // Handle special case for zero
            if (expected === 0 && (normalizedInput === '0' || normalizedInput === 'zero' || normalizedInput === 'none')) {
                return true;
            }
            
            // Try parsing as number - but reject decimals
            const numValue = parseInt(normalizedInput, 10);
            if (!isNaN(numValue) && numValue === expected) {
                // Additional check: make sure it's not a decimal
                const floatValue = parseFloat(normalizedInput);
                if (floatValue === numValue) { // Only true if no decimal part
                    return true;
                }
            }
            
            // Try parsing as word
            const wordValue = window.wordToNumber ? window.wordToNumber(normalizedInput) : null;
            const result = wordValue === expected;
            
            // Debug logging for failed cases
            if (!result && expected !== 0) {
                console.log(`Numeric validation failed: input="${input}", normalized="${normalizedInput}", expected=${expected}, numValue=${numValue}, wordValue=${wordValue}`);
            }
            
            return result;
        }

        function validateEdgeCase(input, expected) {
            if (!input || !expected) return false;
            const normalizedInput = normalizeInput(input);
            const normalizedExpected = normalizeInput(expected);
            return normalizedInput === normalizedExpected;
        }

        function normalizeInput(input) {
            if (!input) return '';
            
            // Normalize whitespace and separators
            let normalized = input
                .replace(/[\t\n\r]+/g, ' ') // Replace tabs/newlines with spaces
                .replace(/,\s*/g, ' ') // Replace commas with spaces
                .replace(/\s+/g, ' ') // Normalize multiple spaces to single space
                .trim();
            
            // Normalize accidentals to Unicode
            if (window.accidentalToUnicode) {
                normalized = normalized.split(' ').map(note => window.accidentalToUnicode(note)).join(' ');
            }
            
            return normalized.toUpperCase();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Comprehensive test suite loaded');
            console.log('Available test categories:', Object.keys(TEST_SUITE));
        });
    </script>
</body>
</html> 