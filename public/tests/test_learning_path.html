<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learning Path Progression Test</title>
    <link rel="stylesheet" href="css/test-suite.css">
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Test Suite</a>
        <div class="header">
            <h1>üéØ Learning Path Progression Test</h1>
            <p>This test simulates the complete learning path to verify the app's logic.</p>
        </div>
        
        <div class="content-box">
            <div id="summary" class="summary" style="display:none;">
                 <div id="stats" class="stats-grid"></div>
            </div>
            <div class="controls">
                <button onclick="runTest()" class="btn">Run Learning Path Test</button>
                <button onclick="clearOutput()" class="btn">Clear Output</button>
                <button onclick="copyJSON()" class="btn">Copy JSON</button>
            </div>
            
            <div id="copy-status" class="status-area"></div>
            
            <div class="output-container">
                <h3>Test Results:</h3>
                <pre id="output">Click "Run Learning Path Test" to start...</pre>
            </div>
            
            <div class="output-container">
                <h3>JSON Output:</h3>
                <pre id="json-output">JSON output will appear here...</pre>
            </div>
        </div>
    </div>

    <script src="../js/data/quizData.js"></script>
    <script src="../js/utils/normalization.js"></script>
    <script>
        // Learning path data is now loaded from quizData.js
        function ordinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function simulateLearningPath() {
            const results = {
                path: [],
                summary: [],
                json: {
                    totalQuestions: 0,
                    levelProgression: [],
                    errors: []
                }
            };
            
            // Initialize state
            let state = {
                currentLevelIndex: 0,
                currentChapterIndex: 0,
                currentKeyIndex: 0,
                correctAnswerStreak: 0,
                usedDegrees: [],
                correctChordAnswersForCurrentKey: 0
            };
            
            let questionCount = 0;
            const maxQuestions = 1000; // Safety limit
            
            while (state.currentLevelIndex < learningPath.length && questionCount < maxQuestions) {
                const level = learningPath[state.currentLevelIndex];
                
                if (!level || level.mode === 'complete') { // Check for undefined level or complete mode
                    break;
                }
                
                // Determine current key and chapter
                let key, chapter;
                
                if (level.mode === MODES.LINEAR) {
                    key = level.keys[state.currentKeyIndex];
                    chapter = level.chapters[state.currentChapterIndex];
                } else if (level.mode === MODES.RANDOM_KEYS_LINEAR_CHAPTERS) {
                    // For testing, we'll use the first key to make it predictable
                    key = level.keys[0];
                    chapter = level.chapters[state.currentChapterIndex];
                } else if (level.mode === MODES.RANDOM_ALL) {
                    // For testing, we'll use the first key and first chapter to make it predictable
                    key = level.keys[0];
                    chapter = level.chapters[0];
                }
                
                // Skip accidentals naming for C major
                if (key === 'C' && chapter.id === QUESTION_TYPES.ACCIDENTALS_NAMES) {
                    state.currentChapterIndex++;
                    continue;
                }
                
                // Generate question text and degree (simulating askQuestion logic)
                let questionText = '';
                let degree = null;
                
                switch (chapter.id) {
                    case QUESTION_TYPES.ACCIDENTALS_COUNT:
                        questionText = `How many accidentals are in ${key} major?`;
                        break;
                    case QUESTION_TYPES.ACCIDENTALS_NAMES:
                        questionText = `Name the accidentals in ${key} major.`;
                        break;
                    case QUESTION_TYPES.SCALE_SPELLING:
                        questionText = `Spell the ${key} major scale.`;
                        break;
                    case QUESTION_TYPES.TRIADS:
                    case QUESTION_TYPES.SEVENTHS:
                    case QUESTION_TYPES.SEVENTH_SPELLING:
                        const allDegrees = [2, 3, 4, 5, 6, 7];
                        let availableDegrees = allDegrees.filter(d => !state.usedDegrees.includes(d));
                        
                        if (availableDegrees.length === 0) {
                            // All degrees have been used for this key
                            if (level.mode !== MODES.LINEAR) {
                                state.usedDegrees = [];
                                availableDegrees = allDegrees;
                            }
                        }
                        
                        degree = availableDegrees[Math.floor(Math.random() * availableDegrees.length)];
                        const chordType = chapter.id === QUESTION_TYPES.TRIADS ? 'triad' : 'seventh chord';
                        const action = chapter.id === QUESTION_TYPES.SEVENTH_SPELLING ? 'Spell' : 'Name';
                        questionText = `${action} the ${ordinal(degree)} ${chordType} in ${key} major.`;
                        break;
                }
                
                // Record the question
                questionCount++;
                const questionRecord = {
                    questionNumber: questionCount,
                    level: level.name,
                    levelIndex: state.currentLevelIndex,
                    key: key,
                    chapter: chapter.name,
                    chapterIndex: state.currentChapterIndex,
                    keyIndex: state.currentKeyIndex,
                    mode: level.mode,
                    question: questionText,
                    degree: degree,
                    streak: state.correctAnswerStreak,
                    usedDegrees: [...state.usedDegrees]
                };
                
                results.path.push(questionRecord);
                
                // Simulate correct answer (simulating handleAnswerSubmit logic)
                state.correctAnswerStreak++;
                
                // Handle progression based on mode
                if (level.mode === MODES.LINEAR) {
                    if (chapter.id === QUESTION_TYPES.TRIADS) {
                        state.correctChordAnswersForCurrentKey++;
                        
                        // Add the degree to usedDegrees to prevent asking the same chord again
                        if (degree) {
                            state.usedDegrees.push(degree);
                        }
                        
                        if (state.correctChordAnswersForCurrentKey >= 3) {
                            // Move to next key
                            state.correctChordAnswersForCurrentKey = 0;
                            state.usedDegrees = [];
                            state.currentKeyIndex++;
                            
                            if (state.currentKeyIndex >= level.keys.length) {
                                // Move to next level
                                state.currentLevelIndex++;
                                state.currentChapterIndex = 0;
                                state.currentKeyIndex = 0;
                                state.correctAnswerStreak = 0;
                                
                                const nextLevel = learningPath[state.currentLevelIndex];
                                
                                const summaryMessage = `‚úÖ Completed ${level.name} -> ${nextLevel ? nextLevel.name : 'Test Complete!'}`;
                                results.summary.push(summaryMessage);
                                results.json.levelProgression.push({
                                    from: level.name,
                                    to: nextLevel ? nextLevel.name : 'Test Complete!',
                                    questionsInLevel: questionCount - (results.json.totalQuestions || 0)
                                });
                                results.json.totalQuestions = questionCount;
                            } else {
                                // Reset to first chapter for new key
                                state.currentChapterIndex = 0;
                            }
                        }
                    } else {
                        // Not a chord question - advance normally
                        state.currentChapterIndex++;
                        if (state.currentChapterIndex >= level.chapters.length) {
                            state.currentChapterIndex = 0;
                        }
                    }
                } else {
                    // Non-linear modes use streak-based progression
                    if (state.correctAnswerStreak >= level.requiredStreak) {
                        state.currentLevelIndex++;
                        state.currentChapterIndex = 0;
                        state.currentKeyIndex = 0;
                        state.correctAnswerStreak = 0;
                        state.usedDegrees = [];
                        
                        const nextLevel = learningPath[state.currentLevelIndex];
                        
                        const summaryMessage = `‚úÖ Completed ${level.name} -> ${nextLevel ? nextLevel.name : 'Test Complete!'}`;
                        results.summary.push(summaryMessage);
                        results.json.levelProgression.push({
                            from: level.name,
                            to: nextLevel ? nextLevel.name : 'Test Complete!',
                            questionsInLevel: questionCount - (results.json.totalQuestions || 0)
                        });
                        results.json.totalQuestions = questionCount;
                    } else {
                        state.currentChapterIndex++;
                        if (state.currentChapterIndex >= level.chapters.length) {
                            state.currentChapterIndex = 0;
                        }
                    }
                }
            }
            
            return results;
        }

        function runTest() {
            const output = document.getElementById('output');
            const jsonOutput = document.getElementById('json-output');
            
            output.textContent = 'Running test...';
            jsonOutput.textContent = 'Running test...';

            // Use a timeout to allow the UI to update before the heavy lifting
            setTimeout(() => {
                const results = simulateLearningPath();
                
                displayResults(results);
            }, 50);
        }

        function displayResults(results) {
            const output = document.getElementById('output');
            const jsonOutput = document.getElementById('json-output');
            const summaryDiv = document.getElementById('summary');
            const statsGrid = document.getElementById('stats');

            output.textContent = results.path.map(p => 
                `Q${p.questionNumber.toString().padStart(2, '0')}: [${p.level}] - ${p.question} (Streak: ${p.streak})`
            ).join('\n');

            jsonOutput.textContent = JSON.stringify(results.json, null, 2);
            
            const totalQuestions = results.json.totalQuestions;
            const levelsCompleted = results.json.levelProgression.length;
            const errorsEncountered = results.json.errors.length;

            statsGrid.innerHTML = `
                <p><strong>Test Complete!</strong></p>
                <p><strong>Total Questions Simulated:</strong> ${totalQuestions}</p>
                <p><strong>Levels Completed:</strong> ${levelsCompleted}</p>
                <p><strong>Errors Encountered:</strong> ${errorsEncountered} ${errorsEncountered === 0 ? '‚úÖ' : '‚ùå'}</p>
            `;
            summaryDiv.style.display = 'block';
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Click "Run Learning Path Test" to start...';
            document.getElementById('json-output').textContent = 'JSON output will appear here...';
            document.getElementById('copy-status').textContent = '';
        }

        function copyJSON() {
            if (window.lastTestResults) {
                const jsonText = JSON.stringify(window.lastTestResults.json, null, 2);
                navigator.clipboard.writeText(jsonText).then(() => {
                    // Show confirmation on page
                    const copyStatus = document.getElementById('copy-status');
                    copyStatus.textContent = '‚úÖ JSON copied to clipboard successfully!';
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    const copyStatus = document.getElementById('copy-status');
                    copyStatus.textContent = '‚ùå Failed to copy to clipboard. Check console for details.';
                });
            } else {
                const outputDiv = document.getElementById('output');
                outputDiv.textContent += '\n‚ùå No test results to copy. Run the test first.\n';
            }
        }
    </script>
</body>
</html> 