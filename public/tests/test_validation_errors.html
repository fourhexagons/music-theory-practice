<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Validation & Edges</title>
    <link rel="stylesheet" href="css/test-suite.css">
    <style>
        .test-result {
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .test-result.pass {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        
        .test-result.fail {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        
        .test-columns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .status {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Test Suite</a>
        <div class="header">
            <h1>üéµ Validation & Edges</h1>
            <p>This suite checks for symbol mismatches, validation errors, and other edge cases.</p>
        </div>

        <div class="content-box">
            <div id="summary" class="summary" style="display:none;">
                <div id="summary-content"></div>
            </div>
            
            <div class="controls">
                <button onclick="runAllTests()" class="btn">Run All Tests</button>
                <button onclick="copyResults('json')" class="btn">Copy JSON</button>
                <button onclick="copyResults('summary')" class="btn">Copy Summary</button>
            </div>
            <div id="copy-status" class="status-area"></div>
            <div id="results"></div>
        </div>
    </div>

    <script src="../js/data/quizData.js"></script>
    <script src="../js/utils/normalization.js"></script>
    <script src="js/test-dashboard.js"></script>
    <script>
        let testResults = [];

        function checkAnswer(answer, questionType, key, degree) {
            const data = quizData[key];
            if (!data) return false;

            const normalizedAnswer = normalizeChord(answer);
            
            if (questionType === 'SEVENTH_SPELLING') {
                const correctSpelling = data.seventhSpelling[degree].map(n => normalizeRootNote(n).toUpperCase());
                const userSpelling = answer.trim().split(/\s+/).map(n => normalizeRootNote(n).toUpperCase());
                if (correctSpelling.length !== userSpelling.length) return false;
                for (let i = 0; i < correctSpelling.length; i++) {
                    if (correctSpelling[i] !== userSpelling[i]) return false;
                }
                return true;
            }

            const correctChord = (questionType === 'TRIADS') ? data.triads[degree] : data.sevenths[degree];
            return normalizedAnswer.toUpperCase() === normalizeChord(correctChord).toUpperCase();
        }

        function addResult(testName, passed, expected, actual, category) {
            testResults.push({ name: testName, passed, expected, actual, category });
        }

        function displayResults() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            const failed = testResults.filter(r => !r.passed);
            const passed = testResults.filter(r => r.passed);
            
            if (failed.length > 0) {
                const failHeader = document.createElement('h2');
                failHeader.textContent = '‚ùå Failing Tests';
                failHeader.style.color = '#dc3545';
                resultsDiv.appendChild(failHeader);
                
                const failContainer = document.createElement('div');
                failContainer.className = 'test-columns';
                failed.forEach(result => {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'test-result fail';
                    resultDiv.innerHTML = `
                        <strong>${result.name}</strong> <span class="status">‚ùå FAIL</span><br>
                        <em>Expected:</em> ${result.expected}, <em>Actual:</em> ${result.actual}<br>
                        <em>Category:</em> ${result.category}
                    `;
                    failContainer.appendChild(resultDiv);
                });
                resultsDiv.appendChild(failContainer);
            }
            
            if (passed.length > 0) {
                const passHeader = document.createElement('h2');
                passHeader.textContent = '‚úÖ Passing Tests';
                passHeader.style.color = '#28a745';
                passHeader.style.marginTop = '2rem';
                resultsDiv.appendChild(passHeader);
                
                const passContainer = document.createElement('div');
                passContainer.className = 'test-columns';
                passed.forEach(result => {
                    const resultDiv = document.createElement('div');
                    resultDiv.className = 'test-result pass';
                    resultDiv.innerHTML = `
                        <strong>${result.name}</strong> <span class="status">‚úÖ PASS</span><br>
                        <em>Expected:</em> ${result.expected}, <em>Actual:</em> ${result.actual}<br>
                        <em>Category:</em> ${result.category}
                    `;
                    passContainer.appendChild(resultDiv);
                });
                resultsDiv.appendChild(passContainer);
            }

            const passCount = testResults.filter(r => r.passed).length;
            const failCount = testResults.length - passCount;
            const successRate = testResults.length > 0 ? Math.round((passCount / testResults.length) * 100) : 0;
            const summaryContent = document.getElementById('summary-content');
            summaryContent.innerHTML = `
                <p><strong>Total Tests:</strong> ${testResults.length}</p>
                <p><strong>Passed:</strong> ${passCount} ‚úÖ</p>
                <p><strong>Failed:</strong> ${failCount} ‚ùå</p>
                <p><strong>Success Rate:</strong> ${successRate}%</p>
            `;
            document.getElementById('summary').style.display = 'block';
            
            // Save results to dashboard
            if (window.TestDashboard) {
                window.TestDashboard.saveTestResult('test_validation_errors.html', {
                    total: testResults.length,
                    passed: passCount,
                    failed: failCount,
                    successRate: successRate
                });
            }
        }

        function testSymbolMismatches() {
            const testCases = [
                // Seventh chord spelling tests with different notations
                { name: 'A Major V7 Spelling (Sharp)', answer: 'E G# B D', key: 'A', degree: 5, expected: true },
                { name: 'G Major V7 Spelling (Sharp)', answer: 'D F# A C', key: 'G', degree: 5, expected: true },
                { name: 'F Major V7 Spelling (Flat)', answer: 'C E G Bb', key: 'F', degree: 5, expected: true },
                { name: 'Bb Major V7 Spelling (Flat)', answer: 'F A C Eb', key: 'Bb', degree: 5, expected: true },
                { name: 'C Major I7 Spelling', answer: 'C E G B', key: 'C', degree: 1, expected: true },
                { name: 'D Major ii7 Spelling', answer: 'E G B D', key: 'D', degree: 2, expected: true },
                { name: 'E Major vii7 Spelling', answer: 'D# F# A C#', key: 'E', degree: 7, expected: true },
                
                // Edge cases with different spacing and formatting
                { name: 'Extra Spaces', answer: 'E  G#  B  D', key: 'A', degree: 5, expected: true },
                { name: 'Mixed Case', answer: 'e g# b d', key: 'A', degree: 5, expected: true },
                { name: 'Mixed Notation', answer: 'E G‚ôØ B D', key: 'A', degree: 5, expected: true },
                { name: 'Unicode Sharp', answer: 'E G‚ôØ B D', key: 'A', degree: 5, expected: true },
                { name: 'Unicode Flat', answer: 'C E G B‚ô≠', key: 'F', degree: 5, expected: true },
                
                // Incorrect spellings that should fail
                { name: 'Wrong Note Order', answer: 'G# E B D', key: 'A', degree: 5, expected: false },
                { name: 'Missing Note', answer: 'E G# B', key: 'A', degree: 5, expected: false },
                { name: 'Extra Note', answer: 'E G# B D F', key: 'A', degree: 5, expected: false },
                { name: 'Wrong Note', answer: 'E G# B C', key: 'A', degree: 5, expected: false }
            ];
            testCases.forEach(tc => {
                const result = checkAnswer(tc.answer, 'SEVENTH_SPELLING', tc.key, tc.degree);
                addResult(tc.name, result === tc.expected, tc.expected, result, 'Symbol Mismatches');
            });
        }
        
        function testValidationLogic() {
            const testCases = [
                // Basic triad validation
                { name: 'Correct Triad (Minor)', answer: 'Gm', key: 'F', degree: 2, type: 'TRIADS', expected: true },
                { name: 'Correct Triad (Major)', answer: 'F', key: 'F', degree: 1, type: 'TRIADS', expected: true },
                { name: 'Correct Triad (Diminished)', answer: 'B¬∞', key: 'C', degree: 7, type: 'TRIADS', expected: true },
                { name: 'Incorrect Triad Type', answer: 'G', key: 'F', degree: 2, type: 'TRIADS', expected: false },
                { name: 'Wrong Triad', answer: 'Am', key: 'F', degree: 2, type: 'TRIADS', expected: false },
                
                // Basic seventh validation
                { name: 'Correct Seventh (Dominant)', answer: 'C7', key: 'F', degree: 5, type: 'SEVENTHS', expected: true },
                { name: 'Correct Seventh (Major)', answer: 'Fmaj7', key: 'F', degree: 1, type: 'SEVENTHS', expected: true },
                { name: 'Correct Seventh (Minor)', answer: 'Dm7', key: 'C', degree: 2, type: 'SEVENTHS', expected: true },
                { name: 'Correct Seventh (Half-dim)', answer: 'Bm7‚ô≠5', key: 'C', degree: 7, type: 'SEVENTHS', expected: true },
                { name: 'Incorrect Seventh Type', answer: 'Cmaj7', key: 'F', degree: 5, type: 'SEVENTHS', expected: false },
                { name: 'Wrong Seventh', answer: 'D7', key: 'F', degree: 5, type: 'SEVENTHS', expected: false }
            ];
            testCases.forEach(tc => {
                const result = checkAnswer(tc.answer, tc.type, tc.key, tc.degree);
                addResult(tc.name, result === tc.expected, tc.expected, result, 'Validation Logic');
            });
        }

        function testNormalizationEdgeCases() {
            const testCases = [
                // Different chord notation variations
                { name: 'Diminished Symbol (¬∞)', answer: 'B¬∞', key: 'C', degree: 7, type: 'TRIADS', expected: true },
                { name: 'Diminished Text (dim)', answer: 'Bdim', key: 'C', degree: 7, type: 'TRIADS', expected: true },
                { name: 'Minor Symbol (m)', answer: 'Dm', key: 'C', degree: 2, type: 'TRIADS', expected: true },
                { name: 'Minor Text (min)', answer: 'Dmin', key: 'C', degree: 2, type: 'TRIADS', expected: true },
                { name: 'Major Seventh (maj7)', answer: 'Cmaj7', key: 'C', degree: 1, type: 'SEVENTHS', expected: true },
                { name: 'Major Seventh (M7)', answer: 'CM7', key: 'C', degree: 1, type: 'SEVENTHS', expected: true },
                { name: 'Half Diminished (m7‚ô≠5)', answer: 'Bm7‚ô≠5', key: 'C', degree: 7, type: 'SEVENTHS', expected: true },
                { name: 'Half Diminished (√∏)', answer: 'B√∏', key: 'C', degree: 7, type: 'SEVENTHS', expected: true },
                { name: 'Half Diminished (halfdim)', answer: 'Bhalfdim', key: 'C', degree: 7, type: 'SEVENTHS', expected: true },
                
                // Case sensitivity
                { name: 'Lowercase Chord', answer: 'gm', key: 'F', degree: 2, type: 'TRIADS', expected: true },
                { name: 'Mixed Case Chord', answer: 'Gm', key: 'F', degree: 2, type: 'TRIADS', expected: true },
                { name: 'Uppercase Chord', answer: 'GM', key: 'F', degree: 2, type: 'TRIADS', expected: false }
            ];
            testCases.forEach(tc => {
                const result = checkAnswer(tc.answer, tc.type, tc.key, tc.degree);
                addResult(tc.name, result === tc.expected, tc.expected, result, 'Normalization Edge Cases');
            });
        }

        function testInputValidation() {
            const testCases = [
                // Empty and invalid inputs
                { name: 'Empty String', answer: '', key: 'C', degree: 1, type: 'TRIADS', expected: false },
                { name: 'Whitespace Only', answer: '   ', key: 'C', degree: 1, type: 'TRIADS', expected: false },
                { name: 'Invalid Chord Name', answer: 'XYZ', key: 'C', degree: 1, type: 'TRIADS', expected: false },
                { name: 'Partial Chord Name', answer: 'G', key: 'F', degree: 2, type: 'TRIADS', expected: false },
                { name: 'Extra Characters', answer: 'Gm7extra', key: 'F', degree: 2, type: 'TRIADS', expected: false },
                
                // Malformed inputs
                { name: 'Numbers Only', answer: '123', key: 'C', degree: 1, type: 'TRIADS', expected: false },
                { name: 'Special Characters', answer: 'G@m', key: 'F', degree: 2, type: 'TRIADS', expected: false },
                { name: 'Multiple Chords', answer: 'Gm Am', key: 'F', degree: 2, type: 'TRIADS', expected: false }
            ];
            testCases.forEach(tc => {
                const result = checkAnswer(tc.answer, tc.type, tc.key, tc.degree);
                addResult(tc.name, result === tc.expected, tc.expected, result, 'Input Validation');
            });
        }

        function testAccidentalHandling() {
            const testCases = [
                // Sharp notation variations - test that normalization works
                { name: 'Sharp Symbol (#)', answer: 'C#m', key: 'A', degree: 3, type: 'TRIADS', expected: true },
                { name: 'Unicode Sharp (‚ôØ)', answer: 'C‚ôØm', key: 'A', degree: 3, type: 'TRIADS', expected: true },
                { name: 'Double Sharp (##)', answer: 'F##', key: 'F#', degree: 4, type: 'TRIADS', expected: false },
                { name: 'Double Sharp (x)', answer: 'Fx', key: 'F#', degree: 4, type: 'TRIADS', expected: false },
                
                // Flat notation variations
                { name: 'Flat Symbol (b)', answer: 'Bb', key: 'F', degree: 4, type: 'TRIADS', expected: true },
                { name: 'Unicode Flat (‚ô≠)', answer: 'B‚ô≠', key: 'F', degree: 4, type: 'TRIADS', expected: true },
                { name: 'Double Flat (bb)', answer: 'Bbb', key: 'Cb', degree: 7, type: 'TRIADS', expected: false },
                
                // Mixed accidentals
                { name: 'Sharp and Flat', answer: 'C#m7‚ô≠5', key: 'D', degree: 7, type: 'SEVENTHS', expected: true },
                { name: 'Natural and Sharp', answer: 'E7', key: 'A', degree: 5, type: 'SEVENTHS', expected: true }
            ];
            testCases.forEach(tc => {
                const result = checkAnswer(tc.answer, tc.type, tc.key, tc.degree);
                addResult(tc.name, result === tc.expected, tc.expected, result, 'Accidental Handling');
            });
        }

        function runAllTests() {
            testResults = [];
            testSymbolMismatches();
            testValidationLogic();
            testNormalizationEdgeCases();
            testInputValidation();
            testAccidentalHandling();
            displayResults();
        }

        let lastCopyData = null;

        function copyResults(format) {
            const passCount = testResults.filter(r => r.passed).length;
            const failCount = testResults.length - passCount;

            if (format === 'json') {
                lastCopyData = JSON.stringify({
                    summary: { total: testResults.length, passed: passCount, failed: failCount },
                    results: testResults
                }, null, 2);
            } else if (format === 'summary') {
                let summaryText = `Test Summary:\n- Total: ${testResults.length}\n- Passed: ${passCount}\n- Failed: ${failCount}\n\n`;
                summaryText += testResults.filter(r => !r.passed).map(r => `FAILED: ${r.name} (Expected: ${r.expected}, Got: ${r.actual})`).join('\n');
                lastCopyData = summaryText;
            }

            navigator.clipboard.writeText(lastCopyData).then(() => {
                document.getElementById('copy-status').textContent = `${format.toUpperCase()} copied to clipboard!`;
            }).catch(err => {
                document.getElementById('copy-status').textContent = `Failed to copy.`;
            });
        }
    </script>
</body>
</html> 