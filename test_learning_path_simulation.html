<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéì Learning Path Progression Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 700px;
            overflow-y: auto;
        }
        
        .level-header { 
            color: #4fc3f7; 
            font-size: 1.2rem; 
            font-weight: bold;
            background: rgba(79, 195, 247, 0.2);
            padding: 8px 12px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .question-item { margin: 3px 0; padding: 6px; border-radius: 5px; }
        .accCount { background: rgba(255, 87, 87, 0.2); border-left: 3px solid #ff5757; }
        .accNotes { background: rgba(255, 193, 7, 0.2); border-left: 3px solid #ffc107; }
        .scale { background: rgba(76, 175, 80, 0.2); border-left: 3px solid #4caf50; }
        .triads { background: rgba(33, 150, 243, 0.2); border-left: 3px solid #2196f3; }
        .sevenths { background: rgba(156, 39, 176, 0.2); border-left: 3px solid #9c27b0; }
        .pair-indicator { background: rgba(255, 152, 0, 0.3); border: 1px solid #ff9800; }
        .streak-info { color: #81c784; font-weight: bold; }
        .level-complete { color: #4caf50; font-weight: bold; background: rgba(76, 175, 80, 0.3); padding: 5px; border-radius: 3px; }
        .progression-info { color: #ffeb3b; font-weight: bold; }
        .error { color: #ff5757; font-weight: bold; }
        .success { color: #4caf50; font-weight: bold; }
        
        .json-output {
            background: rgba(0, 0, 0, 0.5);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .copy-button {
            background: #4CAF50;
            border: none;
            margin-top: 10px;
        }
        
        .copy-button:hover {
            background: #45a049;
        }
        
        .summary {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .summary h3 {
            color: #4fc3f7;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéì Learning Path Progression Test</h1>
        <p style="text-align: center; font-style: italic; margin-bottom: 30px;">
            Tests the complete learning path progression from fresh start to completion<br>
            Simulates the actual user experience of "Start Over" ‚Üí Complete All 12 Levels
        </p>
        
        <div class="controls">
            <button onclick="runFullLearningPath()">üöÄ Run Complete Learning Path</button>
            <button onclick="runFirstThreeLevels()">üéØ Test First 3 Levels</button>
            <button onclick="runAccidentalsPairingLevels()">üîó Test Pairing Levels</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
        </div>
        
        <div id="results"></div>
        <div id="json-output"></div>
    </div>

    <script>
        const QUESTION_TYPES = {
            ACCIDENTALS_COUNT: 'accCount',
            ACCIDENTALS_NAMES: 'accNotes',
            SCALE_SPELLING: 'scale',
            TRIADS: 'triads',
            SEVENTHS: 'sevenths',
            SEVENTH_SPELLING: 'seventhSpelling'
        };

        const MODES = {
            LINEAR: 'linear',
            RANDOM_KEYS_LINEAR_CHAPTERS: 'random_keys_linear_chapters',
            RANDOM_ALL: 'random_all',
            COMPLETE: 'complete'
        };

        const CORE_CHAPTERS = [
            { id: QUESTION_TYPES.ACCIDENTALS_COUNT, name: 'Accidentals Count' },
            { id: QUESTION_TYPES.ACCIDENTALS_NAMES, name: 'Accidentals Naming' },
            { id: QUESTION_TYPES.SCALE_SPELLING, name: 'Scale Spelling' },
            { id: QUESTION_TYPES.TRIADS, name: 'Triads' },
            { id: QUESTION_TYPES.SEVENTHS, name: 'Sevenths' }
        ];

        const ALL_CHAPTERS = [
            ...CORE_CHAPTERS,
            { id: QUESTION_TYPES.SEVENTH_SPELLING, name: 'Seventh Spelling' }
        ];

        // Real Learning Path (matches the actual app)
        const LEARNING_PATH = [
            { name: '1. Introduction', keys: ['C'], mode: MODES.LINEAR, chapters: CORE_CHAPTERS, requiredStreak: 3 },
            { name: '2. Level 1a Sharps', keys: ['G', 'D', 'A'], mode: MODES.LINEAR, chapters: CORE_CHAPTERS, requiredStreak: 3 },
            { name: '3. Level 1b Sharps', keys: ['G', 'D', 'A'], mode: MODES.RANDOM_KEYS_LINEAR_CHAPTERS, chapters: CORE_CHAPTERS, requiredStreak: 5 },
            { name: '4. Level 1a Flats', keys: ['F', 'Bb', 'Eb'], mode: MODES.LINEAR, chapters: CORE_CHAPTERS, requiredStreak: 3 },
            { name: '5. Level 1b Flats', keys: ['F', 'Bb', 'Eb'], mode: MODES.RANDOM_KEYS_LINEAR_CHAPTERS, chapters: CORE_CHAPTERS, requiredStreak: 5 },
            { name: '6. Level 2a Sharps', keys: ['E', 'B', 'F#'], mode: MODES.LINEAR, chapters: CORE_CHAPTERS, requiredStreak: 3 },
            { name: '7. Level 2b Sharps', keys: ['E', 'B', 'F#'], mode: MODES.RANDOM_KEYS_LINEAR_CHAPTERS, chapters: CORE_CHAPTERS, requiredStreak: 5 },
            { name: '8. Level 2a Flats', keys: ['Ab', 'Db', 'Gb'], mode: MODES.LINEAR, chapters: CORE_CHAPTERS, requiredStreak: 3 },
            { name: '9. Level 2b Flats', keys: ['Ab', 'Db', 'Gb'], mode: MODES.RANDOM_KEYS_LINEAR_CHAPTERS, chapters: CORE_CHAPTERS, requiredStreak: 5 },
            { name: '10. Level 3 Sharps', keys: ['C', 'G', 'D', 'A', 'E', 'B', 'F#'], mode: MODES.RANDOM_ALL, chapters: ALL_CHAPTERS, requiredStreak: 5 },
            { name: '11. Level 3 Flats', keys: ['C', 'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb'], mode: MODES.RANDOM_ALL, chapters: ALL_CHAPTERS, requiredStreak: 5 },
            { name: 'Complete!', keys: [], mode: MODES.COMPLETE, chapters: [], requiredStreak: Infinity }
        ];

        const mockQuizData = {
            'C': { accidentals: 0, notes: [] },
            'G': { accidentals: 1, notes: ['F#'] },
            'D': { accidentals: 2, notes: ['F#', 'C#'] },
            'A': { accidentals: 3, notes: ['F#', 'C#', 'G#'] },
            'E': { accidentals: 4, notes: ['F#', 'C#', 'G#', 'D#'] },
            'B': { accidentals: 5, notes: ['F#', 'C#', 'G#', 'D#', 'A#'] },
            'F#': { accidentals: 6, notes: ['F#', 'C#', 'G#', 'D#', 'A#', 'E#'] },
            'C#': { accidentals: 7, notes: ['F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'] },
            'F': { accidentals: 1, notes: ['Bb'] },
            'Bb': { accidentals: 2, notes: ['Bb', 'Eb'] },
            'Eb': { accidentals: 3, notes: ['Bb', 'Eb', 'Ab'] },
            'Ab': { accidentals: 4, notes: ['Bb', 'Eb', 'Ab', 'Db'] },
            'Db': { accidentals: 5, notes: ['Bb', 'Eb', 'Ab', 'Db', 'Gb'] },
            'Gb': { accidentals: 6, notes: ['Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb'] },
            'Cb': { accidentals: 7, notes: ['Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb'] }
        };

        let testResults = {
            timestamp: new Date().toISOString(),
            testType: 'Full Learning Path Progression',
            levels: [],
            summary: {
                totalLevels: 0,
                completedLevels: 0,
                totalQuestions: 0,
                pairingTestsPassed: 0,
                pairingTestsFailed: 0,
                errors: []
            }
        };

        function runFullLearningPath() {
            runLearningPathProgression(LEARNING_PATH.length - 1); // All levels except "Complete!"
        }

        function runFirstThreeLevels() {
            runLearningPathProgression(3); // First 3 levels only
        }

        function runAccidentalsPairingLevels() {
            // Test levels with RANDOM_KEYS_LINEAR_CHAPTERS mode
            const pairingLevels = LEARNING_PATH.slice(2, 5); // Levels 3, 4, 5 
            runLearningPathProgression(pairingLevels.length, pairingLevels);
        }

        function runLearningPathProgression(maxLevels, customPath = null) {
            testResults = {
                timestamp: new Date().toISOString(),
                testType: customPath ? 'Partial Learning Path' : 'Full Learning Path Progression',
                levels: [],
                summary: {
                    totalLevels: 0,
                    completedLevels: 0,
                    totalQuestions: 0,
                    pairingTestsPassed: 0,
                    pairingTestsFailed: 0,
                    errors: []
                }
            };

            const pathToTest = customPath || LEARNING_PATH;
            const results = [];
            
            results.push('üéì LEARNING PATH PROGRESSION TEST');
            results.push('=' .repeat(60));
            results.push(`üìÖ Test Run: ${new Date().toLocaleString()}`);
            results.push(`üéØ Testing: ${customPath ? 'Custom Path' : 'Complete Learning Path'}`);
            results.push(`üìö Levels to Complete: ${Math.min(maxLevels, pathToTest.length - 1)}`);
            results.push('');

            // Initialize learning state (fresh start)
            let learningState = {
                currentGroup: 0,      // Start at first level
                currentKeyIndex: 0,   // Start at first key
                currentChapterIndex: 0, // Start at first chapter
                correctAnswersInChapter: 0,
                requiredAnswersPerChapter: 3,
                usedDegrees: [],
                accidentalsPairState: {
                    inProgress: false,
                    currentKey: null,
                    countAnswered: false
                }
            };

            let totalQuestions = 0;
            const maxTotalQuestions = 2000; // Safety limit

            // Progress through each level
            for (let levelIndex = 0; levelIndex < Math.min(maxLevels, pathToTest.length - 1); levelIndex++) {
                const level = pathToTest[levelIndex];
                
                results.push(`\nüìñ LEVEL ${levelIndex + 1}: ${level.name}`);
                results.push('-'.repeat(50));
                results.push(`üîë Keys: [${level.keys.join(', ')}]`);
                results.push(`üéÆ Mode: ${level.mode}`);
                results.push(`üéØ Required Streak: ${level.requiredStreak}`);
                results.push('');

                const levelResult = simulateLevel(level, learningState, totalQuestions);
                results.push(...levelResult.output);
                
                testResults.levels.push(levelResult);
                testResults.summary.totalLevels++;
                testResults.summary.totalQuestions += levelResult.totalQuestions;
                totalQuestions += levelResult.totalQuestions;
                
                if (levelResult.completed) {
                    testResults.summary.completedLevels++;
                } else {
                    testResults.summary.errors.push(`Level ${levelIndex + 1} failed to complete`);
                    break;
                }

                testResults.summary.pairingTestsPassed += levelResult.pairingTestsPassed;
                testResults.summary.pairingTestsFailed += levelResult.pairingTestsFailed;

                // Safety check
                if (totalQuestions >= maxTotalQuestions) {
                    results.push(`‚ö†Ô∏è SAFETY LIMIT REACHED: ${maxTotalQuestions} questions`);
                    break;
                }

                // Advance to next level (simulate automatic progression)
                learningState.currentGroup++;
                learningState.currentKeyIndex = 0;
                learningState.currentChapterIndex = 0;
                learningState.correctAnswersInChapter = 0;
                learningState.usedDegrees = [];
                learningState.accidentalsPairState = {
                    inProgress: false,
                    currentKey: null,
                    countAnswered: false
                };

                results.push(`üéâ LEVEL COMPLETE! Auto-advancing to next level...`);
                results.push('');
            }

            // Add final summary
            results.push('\nüèÜ LEARNING PATH PROGRESSION SUMMARY');
            results.push('=' .repeat(50));
            results.push(`‚úÖ Levels Completed: ${testResults.summary.completedLevels}/${testResults.summary.totalLevels}`);
            results.push(`üìä Total Questions: ${testResults.summary.totalQuestions}`);
            results.push(`üîó Pairing Tests Passed: ${testResults.summary.pairingTestsPassed}`);
            results.push(`üí• Pairing Tests Failed: ${testResults.summary.pairingTestsFailed}`);
            
            const successRate = testResults.summary.totalLevels > 0 ? 
                ((testResults.summary.completedLevels / testResults.summary.totalLevels) * 100).toFixed(1) : 0;
            results.push(`üìà Success Rate: ${successRate}%`);

            if (testResults.summary.errors.length > 0) {
                results.push(`‚ùå Errors: ${testResults.summary.errors.length}`);
                testResults.summary.errors.forEach(error => results.push(`  - ${error}`));
            }

            displayResults(results);
            displayJsonOutput();
        }

        function simulateLevel(level, state, questionOffset) {
            const levelResults = {
                name: level.name,
                mode: level.mode,
                keys: level.keys,
                requiredStreak: level.requiredStreak,
                questions: [],
                pairingTests: [],
                totalQuestions: 0,
                pairingTestsPassed: 0,
                pairingTestsFailed: 0,
                completed: false,
                output: []
            };

            let questionNum = 1;
            let streak = 0;
            const maxQuestionsPerLevel = 200; // Safety limit per level

            while (streak < level.requiredStreak && questionNum <= maxQuestionsPerLevel) {
                try {
                    const question = generateQuestion(level, state);
                    const answer = getCorrectAnswer(question);
                    
                    const questionData = {
                        number: questionOffset + questionNum,
                        text: question.text,
                        key: question.key,
                        type: question.chapterId,
                        answer: answer,
                        streak: streak
                    };

                    levelResults.questions.push(questionData);
                    levelResults.output.push(`Q${questionNum}: ${question.text}`);
                    levelResults.output.push(`   Answer: "${answer}" | Key: ${question.key} | Type: ${question.chapterId}`);
                    
                    // Validate pairing for RANDOM_KEYS_LINEAR_CHAPTERS mode
                    if (level.mode === MODES.RANDOM_KEYS_LINEAR_CHAPTERS) {
                        validatePairing(state, question, levelResults);
                    }
                    
                    // Handle correct answer and advance state
                    const advancement = handleCorrectAnswer(state, question, level);
                    if (advancement.streakAdvanced) {
                        streak++;
                    }
                    
                    levelResults.output.push(`   Streak: ${streak}/${level.requiredStreak}`);
                    
                    if (state.accidentalsPairState.inProgress) {
                        const pairStatus = state.accidentalsPairState.countAnswered ? 'accNotes next' : 'accCount done';
                        levelResults.output.push(`   üîó PAIR: ${pairStatus} (locked key: ${state.accidentalsPairState.currentKey})`);
                    }
                    
                    levelResults.output.push('');
                    questionNum++;

                } catch (error) {
                    levelResults.output.push(`‚ùå ERROR Q${questionNum}: ${error.message}`);
                    break;
                }
            }

            levelResults.totalQuestions = questionNum - 1;
            levelResults.completed = streak >= level.requiredStreak;
            
            const status = levelResults.completed ? '‚úÖ LEVEL COMPLETED' : '‚ùå LEVEL FAILED';
            levelResults.output.push(status);

            return levelResults;
        }

        function generateQuestion(level, state) {
            const key = determineKey(level, state);
            const chapter = determineChapter(level, state, key);
            
            return {
                key,
                chapterId: chapter.id,
                text: buildQuestionText(key, chapter),
                degree: chapter.id === QUESTION_TYPES.TRIADS || chapter.id === QUESTION_TYPES.SEVENTHS ? 
                    getRandomDegree(state) : null
            };
        }

        function determineKey(level, state) {
            if (state.accidentalsPairState.inProgress) {
                return state.accidentalsPairState.currentKey;
            }
            
            if (level.mode === MODES.LINEAR) {
                return level.keys[state.currentKeyIndex];
            } else {
                // Random key for other modes
                return level.keys[Math.floor(Math.random() * level.keys.length)];
            }
        }

        function determineChapter(level, state, selectedKey) {
            // Handle pairing state
            if (state.accidentalsPairState.inProgress) {
                if (!state.accidentalsPairState.countAnswered) {
                    return level.chapters.find(c => c.id === QUESTION_TYPES.ACCIDENTALS_COUNT);
                } else {
                    // Check if key has accidentals
                    const keyData = mockQuizData[state.accidentalsPairState.currentKey];
                    if (keyData && keyData.accidentals > 0) {
                        return level.chapters.find(c => c.id === QUESTION_TYPES.ACCIDENTALS_NAMES);
                    } else {
                        // No accidentals, end pair
                        state.accidentalsPairState.inProgress = false;
                        state.accidentalsPairState.countAnswered = false;
                        state.accidentalsPairState.currentKey = null;
                        return level.chapters[state.currentChapterIndex];
                    }
                }
            }

            let currentChapter = level.chapters[state.currentChapterIndex];
            
            if (level.mode === MODES.RANDOM_ALL) {
                // Filter chapters for random_all mode
                const availableChapters = level.chapters.filter(ch => 
                    ch.id !== QUESTION_TYPES.ACCIDENTALS_NAMES && 
                    ch.id !== QUESTION_TYPES.SEVENTH_SPELLING
                );
                currentChapter = availableChapters[Math.floor(Math.random() * availableChapters.length)];
            } else if (level.mode === MODES.LINEAR && currentChapter.id === QUESTION_TYPES.ACCIDENTALS_NAMES) {
                // Skip standalone accNotes in linear mode
                const nextIndex = (state.currentChapterIndex + 1) % level.chapters.length;
                currentChapter = level.chapters[nextIndex];
            }
            
            // Set up pairing for accCount in RANDOM_KEYS_LINEAR_CHAPTERS mode
            if (currentChapter.id === QUESTION_TYPES.ACCIDENTALS_COUNT && 
                level.mode === MODES.RANDOM_KEYS_LINEAR_CHAPTERS) {
                state.accidentalsPairState.inProgress = true;
                state.accidentalsPairState.currentKey = selectedKey;
                state.accidentalsPairState.countAnswered = false;
            }
            
            return currentChapter;
        }

        function getRandomDegree(state) {
            const allDegrees = [2, 3, 4, 5, 6, 7];
            let availableDegrees = allDegrees.filter(d => !state.usedDegrees.includes(d));
            
            if (availableDegrees.length === 0) {
                state.usedDegrees = [];
                availableDegrees = allDegrees;
            }
            
            const degree = availableDegrees[Math.floor(Math.random() * availableDegrees.length)];
            state.usedDegrees.push(degree);
            return degree;
        }

        function buildQuestionText(key, chapter) {
            switch (chapter.id) {
                case QUESTION_TYPES.ACCIDENTALS_COUNT:
                    return `How many accidentals are in ${key} major?`;
                case QUESTION_TYPES.ACCIDENTALS_NAMES:
                    return `Name the accidentals in ${key} major.`;
                case QUESTION_TYPES.SCALE_SPELLING:
                    return `Spell the ${key} major scale.`;
                case QUESTION_TYPES.TRIADS:
                    return `Name a triad in ${key} major.`;
                case QUESTION_TYPES.SEVENTHS:
                    return `Name a seventh chord in ${key} major.`;
                case QUESTION_TYPES.SEVENTH_SPELLING:
                    return `Spell the ii7 chord in ${key} major.`;
                default:
                    return `Question in ${key} major`;
            }
        }

        function getCorrectAnswer(question) {
            const data = mockQuizData[question.key];
            switch (question.chapterId) {
                case QUESTION_TYPES.ACCIDENTALS_COUNT:
                    return data.accidentals.toString();
                case QUESTION_TYPES.ACCIDENTALS_NAMES:
                    return data.notes.length > 0 ? data.notes.join(' ') : 'none';
                case QUESTION_TYPES.SCALE_SPELLING:
                    return `${question.key} major scale`;
                case QUESTION_TYPES.TRIADS:
                    return `${question.key} major triad`;
                case QUESTION_TYPES.SEVENTHS:
                    return `${question.key} maj7 chord`;
                case QUESTION_TYPES.SEVENTH_SPELLING:
                    return `ii7 in ${question.key} major`;
                default:
                    return 'correct';
            }
        }

        function handleCorrectAnswer(state, question, level) {
            let streakAdvanced = false;

            if (question.chapterId === QUESTION_TYPES.ACCIDENTALS_COUNT) {
                const keyData = mockQuizData[question.key];
                
                if (keyData && keyData.accidentals === 0) {
                    // C major: skip accNotes 
                    state.accidentalsPairState.inProgress = false;
                    state.accidentalsPairState.countAnswered = false;
                    state.accidentalsPairState.currentKey = null;
                    streakAdvanced = true;
                    advanceToNextQuestion(state, level);
                } else {
                    // Other keys: set up for accNotes
                    state.accidentalsPairState.countAnswered = true;
                    const accNotesIndex = level.chapters.findIndex(ch => ch.id === QUESTION_TYPES.ACCIDENTALS_NAMES);
                    if (accNotesIndex !== -1) {
                        state.currentChapterIndex = accNotesIndex;
                    }
                    // Don't advance streak yet
                }
            } else if (question.chapterId === QUESTION_TYPES.ACCIDENTALS_NAMES && state.accidentalsPairState.inProgress) {
                // Complete the pair
                state.accidentalsPairState.inProgress = false;
                state.accidentalsPairState.countAnswered = false;
                state.accidentalsPairState.currentKey = null;
                streakAdvanced = true;
                advanceToNextQuestion(state, level);
            } else if (question.chapterId === QUESTION_TYPES.TRIADS || question.chapterId === QUESTION_TYPES.SEVENTHS) {
                // Chord questions require 3 correct answers
                state.correctAnswersInChapter++;
                if (state.correctAnswersInChapter >= state.requiredAnswersPerChapter) {
                    state.correctAnswersInChapter = 0;
                    streakAdvanced = true;
                    advanceToNextQuestion(state, level);
                }
            } else {
                // Normal questions advance immediately
                streakAdvanced = true;
                advanceToNextQuestion(state, level);
            }

            return { streakAdvanced };
        }

        function advanceToNextQuestion(state, level) {
            if (level.mode === MODES.LINEAR) {
                // Linear: complete all chapters in current key, then next key
                state.currentChapterIndex++;
                if (state.currentChapterIndex >= level.chapters.length) {
                    state.currentChapterIndex = 0;
                    state.currentKeyIndex++;
                    if (state.currentKeyIndex >= level.keys.length) {
                        state.currentKeyIndex = 0; // Loop back
                    }
                }
            } else if (level.mode === MODES.RANDOM_KEYS_LINEAR_CHAPTERS) {
                // Random keys, linear chapters
                state.currentChapterIndex++;
                if (state.currentChapterIndex >= level.chapters.length) {
                    state.currentChapterIndex = 0;
                }
            }
            // RANDOM_ALL doesn't need state advancement
        }

        function validatePairing(state, question, levelResults) {
            if (question.chapterId === QUESTION_TYPES.ACCIDENTALS_COUNT) {
                const pairTest = {
                    accCountKey: question.key,
                    accNotesKey: null,
                    passed: false,
                    error: null
                };
                levelResults.pairingTests.push(pairTest);
            } else if (question.chapterId === QUESTION_TYPES.ACCIDENTALS_NAMES && state.accidentalsPairState.inProgress) {
                const lastPairTest = levelResults.pairingTests[levelResults.pairingTests.length - 1];
                if (lastPairTest) {
                    lastPairTest.accNotesKey = question.key;
                    if (lastPairTest.accCountKey === question.key) {
                        lastPairTest.passed = true;
                        levelResults.pairingTestsPassed++;
                    } else {
                        lastPairTest.passed = false;
                        lastPairTest.error = `Key mismatch: accCount(${lastPairTest.accCountKey}) != accNotes(${question.key})`;
                        levelResults.pairingTestsFailed++;
                    }
                }
            }
        }

        function displayResults(results) {
            const resultsDiv = document.getElementById('results');
            let html = '<div class="results">';
            
            results.forEach(line => {
                let className = 'question-item';
                if (line.includes('LEVEL ') && line.includes(':')) className = 'level-header';
                else if (line.includes('accCount')) className += ' accCount';
                else if (line.includes('accNotes')) className += ' accNotes';
                else if (line.includes('scale')) className += ' scale';
                else if (line.includes('triads')) className += ' triads';
                else if (line.includes('sevenths')) className += ' sevenths';
                else if (line.includes('PAIR:')) className = 'pair-indicator';
                else if (line.includes('Streak:')) className = 'streak-info';
                else if (line.includes('COMPLETED')) className = 'level-complete';
                else if (line.includes('Auto-advancing')) className = 'progression-info';
                else if (line.includes('ERROR') || line.includes('FAILED')) className = 'error';
                
                html += `<div class="${className}">${line}</div>`;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        function displayJsonOutput() {
            const jsonDiv = document.getElementById('json-output');
            const jsonString = JSON.stringify(testResults, null, 2);
            
            jsonDiv.innerHTML = `
                <h3>üìã Learning Path Test Results JSON (Copy & Share)</h3>
                <div class="json-output">${jsonString}</div>
                <button class="copy-button" onclick="copyToClipboard()">üìã Copy JSON to Clipboard</button>
            `;
        }

        function copyToClipboard() {
            const jsonString = JSON.stringify(testResults, null, 2);
            navigator.clipboard.writeText(jsonString).then(function() {
                alert('‚úÖ Test results copied to clipboard!');
            }).catch(function(err) {
                console.error('Failed to copy: ', err);
                const textArea = document.createElement('textarea');
                textArea.value = jsonString;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('‚úÖ Test results copied to clipboard! (fallback method)');
            });
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('json-output').innerHTML = '';
        }
    </script>
</body>
</html> 